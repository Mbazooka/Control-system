;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                 NMBS ADT                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#lang racket

(require "./GUI/GUI-adt.rkt"
         "../RAILWAY-ADT/railway-adt.rkt")

(provide make-nmbs-adt)

(define HARDSIM-selection '())

(define (make-nmbs-adt)
  (let ((railway (make-railway-adt))
        (trains-trajectory (make-hash))
        (new-trajectories (make-hash))
        (gui '()))

    (define (update-component-abstraction operation) ;; Abstraction for reoccuring update operation
      (lambda (component state)
        ((railway operation) component state)))

    (define (retrieve-all-abstraction operation) ;; abstraction for reoccuring retrieve-all operation
      (lambda () ((railway operation))))

    (define update-switch! (update-component-abstraction 'change-switch-state!))
    
    (define retrieve-all-switches (retrieve-all-abstraction 'get-all-switches))

    (define (update-barrier! barrier state) 
      (let ((processed-data (if (= state 0) 'open 'close)))
        ((railway 'change-barrier-state!) barrier processed-data)))

    (define retrieve-all-barriers (retrieve-all-abstraction 'get-all-barriers))

    (define update-light! (update-component-abstraction 'change-light-state!))

    (define retrieve-all-lights (retrieve-all-abstraction 'get-all-lights))

    (define retrieve-all-detection-blocks (retrieve-all-abstraction 'get-all-detection-blocks))

    (define update-train! (update-component-abstraction 'change-train-speed!))

    (define retrieve-all-trains (retrieve-all-abstraction 'get-all-trains))

    ;; The following is an abstraction of a reoccuring pattern for updating Hardware
    (define (update-all-abstraction message)
      (lambda (data)
        (for-each
         (lambda (pair)
           (let ((name (car pair))
                 (state (cdr pair)))
             ((railway message) name state)))
         data)))

    (define update-switches! (update-all-abstraction 'change-switch-state!))

    ;; Procedure to update the trains
    (define (update-trains! trains) 
      (for-each
       (lambda (train)
         (let ((train-name (car train))
               (init-track (cadr train))
               (beh-track (caddr train))
               (speed (cadddr train))
               (current-track (car (cddddr train)))
               (current-track-behind (cadr (cddddr train)))
               (traj-state (caddr (cddddr train))))
           ((railway 'add-train!) train-name init-track beh-track)
           ((railway 'change-train-speed!) train-name speed)
           ((railway 'change-train-track!) train-name current-track)
           ((railway 'change-train-track-behind!) train-name current-track-behind)
           ((railway 'change-train-trajectory-state!) train-name traj-state)
           ))
       trains))

    ;; Helper procedure to determine the destination a trajectory
    (define (get-destination trajectory)
      (if (null? trajectory)
          trajectory
          (if (null? (cdr trajectory))
              (car trajectory)
              (get-destination (cdr trajectory)))))

    ;; Helper procedures to adjust the trajectory taken to a correct trajectory
    (define (environment-component? preceded component followed component-list)
      (and (eq? (car component-list) preceded)
           (eq? (cadr component-list) component)
           (eq? (caddr component-list) followed)))

    (define (adjust-single-trajectory component-list)
      (define (adjustment-traj lst . new-elements)
        (cons (car lst) (append new-elements (cddr lst))))
        
      (define (adjust-single-trajec-rec lst)
        (cond
          ((null? lst) '())
          ((null? (cdr lst)) lst)
          ((null? (cddr lst)) lst)
          ((or (environment-component? 'S-2 'S-7 'S-25 lst)
               (environment-component? 'S-25 'S-7 'S-2 lst))
           (adjustment-traj lst 'S-1))
          ((or (environment-component? 'S-1 'S-25 'S-7 lst)
               (environment-component? 'S-7 'S-25 'S-1 lst))
           (adjustment-traj lst 'S-2))
          (else
           (cons (car lst)
                 (adjust-single-trajec-rec (cdr lst))))))
      (adjust-single-trajec-rec component-list))

    (define (adjust-full-trajectory trajectory)
      (map adjust-single-trajectory trajectory))

    ;; Helper procedure for optimization procedure
    (define (common-elements? lst1 lst2)
      (define member-boolean #f)
      (for-each (lambda (element)
                  (if (not (eq? (member element lst2) #f))
                      (set! member-boolean #t)
                      '()))
                lst1)
      member-boolean)

    ;; Procedure to optimize the path so that it doesn't stop and then continue riding in the same direction (might have duplicates, but that's not a problem)
    (define (optimize-trajectory full-trajectory) ;; Determines if the trajectory can be optimized, i.e. completed in one chunk
      (define (optimize-trajectory-iter current-traj rest-traj acc)
        (if (null? rest-traj)
            (append acc (list current-traj))
            (if (common-elements? current-traj (cdar rest-traj))
                (optimize-trajectory-iter (car rest-traj) (cdr rest-traj) (append acc (list current-traj)))
                (optimize-trajectory-iter (append current-traj (car rest-traj)) (cdr rest-traj) acc))))
      (if (not (null? full-trajectory))
          (optimize-trajectory-iter (car full-trajectory) (cdr full-trajectory) '())
          '()))

    ;; Compute the trajectory that must be taken to get to the desired destination
    (define (compute-trajectory start destination) ;; ADDED (ADD TO TESTS)
      (let ((path ((railway 'compute-path-simplified) start destination)))
        (define (compute-individual-trajectory start current-path)
          (if (null? current-path)
              '()
              (let ((individual-path ((railway 'compute-path-complex) start (car current-path))))
                (cons individual-path
                      (compute-individual-trajectory (get-destination individual-path) (cdr current-path))))))
        (optimize-trajectory (adjust-full-trajectory (compute-individual-trajectory start path))))) ;; Sticker to make sure it is the first

    ;; Abstractions
    (define first-traj car)
    (define rest-traj cdr)
    (define destination car)

    ;; Procedure to adjust trajectory to be followed
    (define (adjust-trajectory! train-name trajectory)
      (hash-set! new-trajectories train-name trajectory))
    
    ;; Procedure that will add a trajectory for a specific train (to be changed later (current destination), ADDED)
    (define (add-trajectory! train-name destination)
      (cond
        ((hash-ref new-trajectories train-name #f)         
         (if (null? ((railway 'get-train-trajectory-state) train-name)) ;; AVOIDS SPAMMING THE DESTINATION BUTTON
             (adjust-trajectory! train-name (compute-trajectory ((railway 'get-train-track) train-name) destination))
             '()))
        ((hash-ref trains-trajectory train-name #f)
         (if (null? ((railway 'get-train-trajectory-state) train-name))
             (adjust-trajectory! train-name (compute-trajectory ((railway 'get-train-track) train-name) destination))
             '()))))

    ;; Helper procedure to get destination of trajectory
    (define (get-final-destination trajectories)
      (if (null? (cdr trajectories))
          (get-destination (car trajectories))
          (get-final-destination (cdr trajectories))))

    ;; Procedure that will retrieve the trajectories
    (define (retrieve-trajectories)
      (let ((return-val (hash->list new-trajectories)))
        (hash-for-each new-trajectories
                       (lambda (train data)
                         (hash-set! trains-trajectory train data)))
        (hash-clear! new-trajectories)
        return-val))

    (define (apply-train! train-name track track-behind) ;; Adds a train to the track
      (if (and (not ((railway 'get-detection-block-reservation) track)) ((railway 'add-train!) train-name track track-behind)) ;; Avoids adding when there is a train
          (begin
            (hash-set! new-trajectories train-name '())
            #t)
          #f)) 

    (define update-detection-blocks! ;; Updates the detection-blocks their states
      (lambda (data-pair reservations)
        (let ((oc-db (car data-pair))
              (all-db (cdr data-pair)))
          ((railway 'update-detection-blocks!) oc-db all-db reservations))))

    ;; Abstraction to retrieve train specific data
    (define (retrieve-train-abstraction operation)
      (lambda (train-name) ((railway operation) train-name)))

    (define retrieve-train-destination (retrieve-train-abstraction 'get-train-destination))

    (define retrieve-train-current-position (retrieve-train-abstraction 'get-train-track))

    (define retrieve-train-current-behind (retrieve-train-abstraction 'get-train-track-behind))

    (set! gui (make-gui-adt update-switch! retrieve-all-switches
                            update-barrier! retrieve-all-barriers
                            update-light! retrieve-all-lights
                            retrieve-all-detection-blocks update-train!
                            apply-train! retrieve-all-trains add-trajectory!
                            retrieve-train-destination retrieve-train-current-position
                            retrieve-train-current-behind)) 
      
    (define (dispatch msg)
      (cond
        ((eq? msg 'retrieve-all-switches) retrieve-all-switches)
        ((eq? msg 'apply-train!) apply-train!)
        ((eq? msg 'retrieve-all-barriers) retrieve-all-barriers)
        ((eq? msg 'retrieve-all-lights) retrieve-all-lights)
        ((eq? msg 'retrieve-all-trains) retrieve-all-trains)
        ((eq? msg 'add-trajectory!) add-trajectory!) 
        ((eq? msg 'retrieve-trajectories) retrieve-trajectories)
        ((eq? msg 'compute-trajectory) compute-trajectory)
        ((eq? msg 'update-trains!) update-trains!)
        ((eq? msg 'update-switches!) update-switches!)
        ((eq? msg 'update-detection-blocks!) update-detection-blocks!)
        (else
         "NMBS-ADT: Illegal message")))
    dispatch))